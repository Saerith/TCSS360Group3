package urbanparks.model;

import static urbanparks.model.ModelConstants.JOB_DATA_FILE;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;


/**
 * Job Collection class
 * This class represents the collection of all jobs used in the Urban Parks application.
 */
public class JobCollection implements Serializable {
	
	private static final long serialVersionUID = -5732921162292711504L;

	private static int currentJobId;

	private HashMap<Long, Job> jobsList;


	/**
	 * Default constructor for JobCollection
	 */
	public JobCollection() {
		jobsList = new HashMap<Long, Job>();
		currentJobId = ModelConstants.DEFAULT_JOB_ID;
	}


	/**
	 * Checks if the number of pending jobs is at capacity
     *
	 * Precondition: ModelConstants must have a maxPendingJobs attribute set to test against.
     *
	 * @return true if the number of pending jobs is at capacity, false otherwise.
	 */
	public boolean isNumJobsAtMaximum() {
		return getPendingJobsCount() >= ModelConstants.getMaxPendingJobs();
	}


	/**
	 * Generate a new unique sequential JobID
     * The JobID is generated by incrementing the current highest JobID.
     *
	 * Postcondition: ID will be unique to all other job IDs in the system in sequential order
	 *  
	 * @return a new valid unique JobID
	 */
	public static int generateNewJobID() {
		currentJobId++;
		return currentJobId;
	}


	/**
	 * Adds a job to the job hash map.
     *
	 * Precondition: Job must be predictably hashable (in the case Job is subclassed and hash is overridden)
     * Postcondition: This collection will contain the given job, which can be looked up by its JobID
     *
	 * @param job The job to add.
	 */
	public void addJob(Job job) {
		jobsList.put(job.getJobId(), job);
	}


	/**
	 * Finds a job in the hash map by its JobID
     *
	 * Postcondition: A job will be returned if its ID exists, and null otherwise.
     * These are the only possible return values
     *
	 * @param id The ID of the job
	 * @return The job that was found. Can be null to indicate an invalid ID.
	 */
	public Job findJob(long id) {
		return jobsList.get(id);
	}


	/**
	 * Returns an int representing the number of PENDING jobs in the collection.
	 * Pending means the job is not cancelled and has not yet ended.
     *
	 * @return Pending jobs in the system
	 */
	public int getPendingJobsCount() {
		int pendingCount = 0;
		for(Map.Entry<Long, Job> entry : jobsList.entrySet()) {
			Job job = entry.getValue();
			if(!job.getIsCancelled() && !job.hasJobEnded()) {
				pendingCount++;
			}
		}
		return pendingCount;
	}
	
	/**
	 * Gets a sorted list of jobs available for a specific volunteer to sign up for.
     *
     * Precondition: The volunteer must exist and be able to sign up for jobs
     * Precondition: There must be jobs available to sign up for
     * Postcondition: A non-null ArrayList will be returned
	 * 
	 * @param volunteer The volunteer to check availability for
	 * @return The list of jobs that volunteer can sign up for
	 */
	public ArrayList<JobAvailability> getAvailableForSignup(Volunteer volunteer) {
		ArrayList<JobAvailability> availableJobs = new ArrayList<JobAvailability>();
		for(Map.Entry<Long, Job> entry : jobsList.entrySet()) {
			Job job = entry.getValue();
			// no jobs that have started should be displayed to user
			if (!job.hasJobStarted()) {
				JobAvailability ja = new JobAvailability(job);
				// check the signing up for job business rules
				// jobs that violate business rules are marked as unavailable
				if (!job.getIsCancelled() && !volunteer.doesJobOverlap(job, this) && job.isSignupEarlyEnough()) {
					ja.setIsAvailable(true);
				} else {
					ja.setIsAvailable(false);
				}
				availableJobs.add(ja);
			}
		}
		sortJobsByStartDate(availableJobs);
		return availableJobs;
	}


	/**
	 * Gets an ArrayList of jobs a given volunteer can unvolunteer from.
     *
     * Precondition: The volunteer must have associated jobs
     * Precondition: The volunteer must be eligible to unvolunteer for jobs
     * Postcondition: An ArrayList will be returned, whether or not it is populated
     *
	 * @param volunteer The volunteer to check for jobs to unvolunteer from
	 * @return
	 */
	public ArrayList<JobAvailability> getAvailableForUnvolunteer(Volunteer volunteer) {
		ArrayList<JobAvailability> availableJobs = new ArrayList<JobAvailability>();
		for(Map.Entry<Long, Job> entry : jobsList.entrySet()) {
			Job job = entry.getValue();
			JobAvailability ja = new JobAvailability(job);
			// check the unvolunteer from job business rules
			// jobs that violate business rules are marked as unavailable
			if (volunteer.isAssociatedWithJob(job.getJobId())) {
				if (!job.getIsCancelled() && job.isUnvolunteerEarlyEnough()) {
					ja.setIsAvailable(true);
				} else {
					ja.setIsAvailable(false);
				}
				availableJobs.add(ja);
			}
		}
		sortJobsByStartDate(availableJobs);
		return availableJobs;
	}
	
	/**
	 * Gets an ArrayList of jobs for a specified park manager that are
	 * available to unsubmit/cancel.
     *
     * Postcondition: An ArrayList will be returned, whether or not it is populated
	 * 
	 * @param parkManager The park manager who wishes to unsubmit a job
	 * @return The list of jobs that park manager created.
	 */
	public ArrayList<JobAvailability> getAvailableForUnsubmit(ParkManager parkManager) {
		ArrayList<JobAvailability> availableJobs = new ArrayList<JobAvailability>();
		for(Map.Entry<Long, Job> entry : jobsList.entrySet()) {
			Job job = entry.getValue();
			if (parkManager.isAssociatedWithJob(job.getJobId())) {
				JobAvailability ja = new JobAvailability(job);
				// check unsubmitting job business rules
				// jobs that violate business rules are marked as unavailable
				if (parkManager.isAssociatedWithJob(job.getJobId())) {
					if (!job.getIsCancelled() && job.isUnsubmitEarlyEnough()) {
						ja.setIsAvailable(true);
					} else {
						ja.setIsAvailable(false);
					}
					availableJobs.add(ja);
				}
			}
		}
		sortJobsByStartDate(availableJobs);
		return availableJobs;
	}
	
	/**
	 * Gets all jobs whose start or end times are between the 2 times, inclusive.
     *
     * Precondition: Lower and upper bounds must be valid job dates
     * Precondition: The lower bound must be sooner than or equal to the upper bound
     * Postcondition: An ArrayList will be returned, whether or not it is populated
     *
	 * @param lowerBound the lower bound which the jobs' start or end times can't be below
	 * @param upperBound the upper bound which the jobs' start or end times can't be above
	 * @return An ArrayList of all jobs that are between the dates
	 */
	public ArrayList<JobAvailability> getJobsBetween2DateTimes(LocalDateTime lowerBound, LocalDateTime upperBound) {
		final ArrayList<JobAvailability> availableJobs = new ArrayList<JobAvailability>();
		for(Map.Entry<Long, Job> entry : jobsList.entrySet()) {
			Job job = entry.getValue();
			JobAvailability ja = new JobAvailability(job);
			if (job.isBetween2DatesInclusive(lowerBound, upperBound)) {
				availableJobs.add(ja);
			}
		}
		sortJobsByStartDate(availableJobs);
		return availableJobs;
	}
	
	/**
	 * Sorts a list of jobs by start date, descending.
     *
     * Precondition: The provided ArrayList must have jobs to compare
     * Postcondition: The sorting will occur in-place
	 * 
	 * @param jobs The jobs to sort
	 */
	private void sortJobsByStartDate(ArrayList<JobAvailability> jobs) {
		Collections.sort(jobs, new Comparator<JobAvailability>() {
	        @Override
	        public int compare(JobAvailability job1, JobAvailability job2) {
	            return job1.getJob().getStartDateTime().compareTo(job2.getJob().getEndDateTime());
	        }
	    });
	}
	
	/**
	 * Saves this job collection's data
     *
     * Precondition: JOB_DATA_FILE must be in a place on the file system that exists or can be created
     * Precondition: Program must have permission to write to the JOB_DATA_FILE location
     * Postcondition: The data will be saved in the place specified by JOB_DATA_FILE
	 * 
	 * @throws IOException
	 */
	public void saveData() throws IOException {
		FileOutputStream fos = new FileOutputStream(JOB_DATA_FILE);
		ObjectOutputStream ois = new ObjectOutputStream(fos);
		ois.writeObject(jobsList);
		ois.close();
	}
	
	/**
	 * Loads this job collection's data
     *
     * Precondition: The JOB_DATA_FILE to load must exist, be readable, and be valid
     * Postcondition: The data will be loaded into this JobCollection
	 * 
	 * @throws IOException 
	 * @throws ClassNotFoundException */
	@SuppressWarnings("unchecked")
	public void loadData() throws IOException, ClassNotFoundException {
		FileInputStream fis = new FileInputStream(JOB_DATA_FILE);
		ObjectInputStream ois = new ObjectInputStream(fis);
		Object object = ois.readObject();
		jobsList = (HashMap<Long, Job>) object;
		currentJobId = jobsList.size();
		ois.close();
	}
}
